--- webkit-efl-svn-r71637/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp.orig	2010-11-09 18:43:06.000000000 +0100
+++ webkit-efl-svn-r71637/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp	2012-01-22 16:10:58.100594266 +0100
@@ -225,7 +225,7 @@
 #ifdef PNG_iCCP_SUPPORTED
     char* profileName;
     int compressionType;
-    char* profile;
+    png_bytep profile;
     png_uint_32 profileLength;
     if (png_get_iCCP(png, info, &profileName, &compressionType, &profile, &profileLength)) {
         ColorProfile colorProfile;
@@ -240,11 +240,11 @@
 {
     png_structp png = m_reader->pngPtr();
     png_infop info = m_reader->infoPtr();
-    png_uint_32 width = png->width;
-    png_uint_32 height = png->height;
+    png_uint_32 width = png_get_image_width(png, info);
+    png_uint_32 height = png_get_image_height(png, info);
     
     // Protect against large images.
-    if (png->width > cMaxPNGSize || png->height > cMaxPNGSize) {
+    if (width > cMaxPNGSize || height > cMaxPNGSize) {
         longjmp(JMPBUF(png), 1);
         return;
     }
@@ -318,8 +318,8 @@
 
     if (m_reader->decodingSizeOnly()) {
         // If we only needed the size, halt the reader.     
-        m_reader->setReadOffset(m_reader->currentBufferSize() - png->buffer_size);
-        png->buffer_size = 0;
+        m_reader->setReadOffset(m_reader->currentBufferSize() - png_get_compression_buffer_size(png));
+        png_set_compression_buffer_size(png, 0);
     }
 }
 
@@ -342,7 +342,7 @@
         // For PNGs, the frame always fills the entire image.
         buffer.setRect(IntRect(IntPoint(), size()));
 
-        if (m_reader->pngPtr()->interlaced)
+        if (png_get_interlace_type(m_reader->pngPtr(), m_reader->infoPtr()) != PNG_INTERLACE_NONE)
             m_reader->createInterlaceBuffer((m_reader->hasAlpha() ? 4 : 3) * size().width() * size().height());
     }
 
